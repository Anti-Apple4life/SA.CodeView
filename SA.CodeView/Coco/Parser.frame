/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
----------------------------------------------------------------------*/
-->begin
using System;
using System.Collections;
using System.Collections.Generic;

-->namespace

partial class Parser
{
    -->constants
    const bool T = true;
    const bool x = false;
    const int minErrDist = 2;

    public Scanner scanner;
    public ErrorCollection Errors;

    public Token t;    // last recognized token
    public Token la;   // lookahead token
    int errDist = minErrDist;

-->declarations

    public Parser(Scanner scanner)
    {
        this.scanner = scanner;
		this.Errors = new ErrorCollection(scanner.FileName);
    }

    void SynErr(int n)
    {
        if (errDist >= minErrDist)
			this.Errors.SynErr(la.line, la.col, n);
        errDist = 0;
    }

    public void SemErr(string msg)
    {
        if (errDist >= minErrDist)
			this.Errors.SemErr(t.line, t.col, msg);
        errDist = 0;
    }
    
    void Get()
    {
        for (; ; )
        {
            t = la;
            la = scanner.Scan();
            if (la.kind <= maxT) { ++errDist; break; }
-->pragmas
            la = t;
        }
    }

    void Expect(int n)
    {
        if (la.kind == n) Get(); else { SynErr(n); }
    }

    bool StartOf(int s)
    {
        return set[s, la.kind];
    }

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
    void ExpectWeak(int n, int follow)
    {
        if (la.kind == n) Get();
        else
        {
            SynErr(n);
            while (!StartOf(follow)) Get();
        }
    }

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
    bool WeakSeparator(int n, int syFol, int repFol)
    {
        int kind = la.kind;
        if (kind == n) { Get(); return true; }
        else if (StartOf(repFol)) { return false; }
        else
        {
            SynErr(n);
            while (!(set[syFol, kind] || set[repFol, kind] || set[0, kind]))
            {
                Get();
                kind = la.kind;
            }
            return StartOf(syFol);
        }
    }


-->productions

    void _Parse()
    {
        la = new Token();
        la.val = "";
        Get();
-->parseRoot

        scanner.RollBack();
    }

    bool[,] set = {
-->initialization
};
} // end Parser


public class ErrorDescription
{
    public enum ErrorType
    {
        Syntax,
        Semantic,
        Warning,
    }
    public string File;
    public string Msg;
    public ErrorType Type;
    public string StringType
    {
		get
		{
			switch(Type)
			{
				case ErrorType.Syntax:
					return "Syntax";
				case ErrorType.Semantic:
					return "Semantic";
				case ErrorType.Warning:
					return "Warning";
				default:
					return "Indefinite error type.";
			}
		}
    }
    public int Row;
    public int Col;
    //=======================================================================================================
    public ErrorDescription()
    {
    }
    //=======================================================================================================
    public ErrorDescription(string file, string msg, ErrorType type, int row, int col)
    {
        File = file;
        Msg = msg;
        Type = type;
        Row = row;
        Col = col;
    }
}


public class ErrorCollection : IEnumerable
{
    public static string errMsgFormat = "Line {0}, col {1}: {2}"; // 0=line, 1=column, 2=text
    List<ErrorDescription> Errors = new List<ErrorDescription>();
	public int NoWarningCount = 0;						//number of errors, not include warnings
	public int WarningCount = 0;						//number of warnings
    string _file;
	
	public int Count
	{
		get
		{
			if (this.Errors == null)
				return 0;
			else
				return this.Errors.Count;
		}
	}
	public IEnumerator GetEnumerator()
	{
		return this.Errors.GetEnumerator();
	}
	public ErrorDescription this[int index]
	{
		get	{	return this.Errors[index];	}
	}
	
    public ErrorCollection(string file)
    {
        _file = file;
    }

    public void SynErr(int line, int col, int n)
    {
        string s;
        switch (n)
        {
-->errors
            default: s = "error " + n; break;
        }

        this.Errors.Add(new ErrorDescription(
            _file,
            string.Format(errMsgFormat, line, col, s),
            ErrorDescription.ErrorType.Syntax,
            line,
            col));

        NoWarningCount++;
    }

    public void SemErr(int line, int col, string s)
    {
        this.Errors.Add(new ErrorDescription(
            _file,
            string.Format(errMsgFormat, line, col, s),
            ErrorDescription.ErrorType.Semantic,
            line,
            col));
        NoWarningCount++;
    }
}

public class AnalyzingException : Exception
{
    public AnalyzingException(string m) : base(m) { }
}
$$$
